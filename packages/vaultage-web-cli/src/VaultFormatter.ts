import { VaultDBEntry } from 'vaultage-client';

export class VaultEntryFormatter {
    
        /**
         * Formats a VaultDBEntry to HTML
         * @param e the VaultDBEntry
         */
        public static format(e : VaultDBEntry): string {
            let stringBuilder = '<span class="entry">'
    
            stringBuilder += `<span class="id col1">(${e.id})</span>`
            stringBuilder += `<span class="title col2">${e.title}</span>&rarr;`
            stringBuilder += `<span class="login col3">${e.login}</span>:`
            stringBuilder += `<span class="password blurred col4">${e.password}</span>@`
            stringBuilder += `<span class="url col5">${e.url}</span>`

            stringBuilder += `<span class="use col6">(used ${e.usage_count} times)</span>`

            if (e.reuse_count>0){
                stringBuilder += `<span class="reuse col7">(warning: re-used ${e.reuse_count} times)</span>`
            }
            stringBuilder += '</span>'
    
            return stringBuilder
        }

        /**
         * Every time a "needle" is found in the haystack function, put this string before
         * @param id the index of the needle (e.g. we already search for some term, and this is the 2nd search term)
         */
        private static highlightPrefix(id : number):string {
            return '<span class="highlight highlight'+id+'">';
        }

        /**
         * Every time a "needle" is found in the haystack function, put this string after
         * @param id 
         */
        private static highlightSuffix():string {
            return '</span>';
        }

        /**
         * Formats the VaultDBEntry, and highlight the terms matching the argument
         * @param e the VaultDBEntry
         * @param highlights all terms to highlight
         */
        public static formatAndHighlight(e : VaultDBEntry, highlights: string[]): string {
            
            e.title = this.highlight(e.title, highlights)
            e.login = this.highlight(e.login, highlights)
            e.password = this.highlight(e.password, highlights)
            e.url = this.highlight(e.url, highlights)
    
            return this.format(e)
        }

        /**
         * Simply colors the needles with the same highlight colors they would be highlighted
         * when searching a text
         * @param needles 
         */
        public static searchTermsToHighlightedString(needles: string[]): string {
            let stringBuilder = ''
            for(let i=0; i<needles.length; i++) {
                stringBuilder += this.highlightPrefix(i) + needles[i] + this.highlightSuffix() + ' '
            }
            return stringBuilder.trim();
        }

        /**
         * Highlights all occurences of the words given
         * @param haystack the text in which the function will highlight words
         * @param needles the words to highlight
         * @param highlightId 
         */
        public static highlight(haystack : string, needles : string[]): string {
            return this._highlight([haystack], needles).join('')
        }

        /**
         * Helper function, called recursively. The intuition is that we split given one needle, then *on each split parts* we
         * continue with the potential remaining needles recursively, before joining the initial parts with the highlighted search
         * term. This is a more complex way than regex search and replace, but it works with overlapping searches, and searches that
         * could hit the highlighting (e.g. searching for "git class" would highlight the "<span class..." generated by the first term)
         * @param haystacks an array of text in which we need to highlight stuff
         * @param remainingNeedles the remaining search terms
         * @param highlightId the current search term index (for choosing the highlight color)
         */
        private static _highlight(haystacks : string[], remainingNeedles : string[], highlightId: number = 0): string[] {

            // if we're out of search terms, the "haystack" does not need to be processed further
            if(remainingNeedles.length == 0){
                return haystacks
            }

            const needle = remainingNeedles[0]
            const newRemainingNeedles = remainingNeedles.slice(1)

            // split each haystack given this search term, then process the resulting parts with the remaining search terms
            const newHaystacks = haystacks.map(haystack => this._highlight(haystack.split(needle), newRemainingNeedles, highlightId+1))

            // now that we subprocessed other terms, the parts that remains are the one split by our needle. Glue them back together
            // with a highlighted needle (glue)
            const glue = this.highlightPrefix(highlightId) + needle + this.highlightSuffix()
            const res = newHaystacks.map(haystacks => haystacks.join(glue))

            return res;
        }
    }